from rdkit import Chem
from rdkit.Chem import AllChem
import math
import subprocess
import torch
import torchani
import numpy as np

#  VSEPR Predictor

def vsepr_predictor(bonded_atoms, lone_pairs):
    vsepr_table = {
        (2, 0): ("Linear", "sp", 180),
        (3, 0): ("Trigonal Planar", "sp2", 120),
        (2, 1): ("Bent", "sp2", 118),
        (4, 0): ("Tetrahedral", "sp3", 109.5),
        (3, 1): ("Trigonal Pyramidal", "sp3", 107),
        (2, 2): ("Bent", "sp3", 104.5),
        (5, 0): ("Trigonal Bipyramidal", "sp3d", "90/120"),
        (4, 1): ("See-Saw", "sp3d", "90/117"),
        (3, 2): ("T-Shaped", "sp3d", 90),
        (2, 3): ("Linear", "sp3d", 180),
        (6, 0): ("Octahedral", "sp3d2", 90),
        (5, 1): ("Square Pyramidal", "sp3d2", "<90"),
        (4, 2): ("Square Planar", "sp3d2", 90),
    }
    steric_number = bonded_atoms + lone_pairs
    return vsepr_table.get((bonded_atoms, lone_pairs), ("Unknown", "Unknown", "Unknown")), steric_number

def estimate_lone_pairs(atom):
    valence_electrons = {
        'H': 1, 'C': 4, 'N': 5, 'O': 6, 'F': 7,
        'P': 5, 'S': 6, 'Cl': 7, 'Br': 7, 'I': 7
    }
    symbol = atom.GetSymbol()
    total_valence = valence_electrons.get(symbol, 0)
    bonded_atoms = atom.GetDegree()
    lone_pairs = max(0, (total_valence - bonded_atoms) // 2)
    return lone_pairs

#  Coordinate Generator
def generate_coordinates(geometry):
    coords = [(0.0, 0.0, 0.0)]  #  For Central atom
    if geometry == "Linear":
        coords += [(1.0, 0.0, 0.0), (-1.0, 0.0, 0.0)]
    elif geometry == "Trigonal Planar":
        angle = 120 * math.pi / 180
        for i in range(3):
            theta = i * angle
            coords.append((math.cos(theta), math.sin(theta), 0.0))
    elif geometry in ["Bent", "Angular"]:
        angle = 104.5 * math.pi / 180
        coords += [(math.cos(angle / 2), math.sin(angle / 2), 0.0),
                   (math.cos(-angle / 2), math.sin(-angle / 2), 0.0)]
    elif geometry == "Tetrahedral":
        coords += [(1.0, 1.0, 1.0), (-1.0, -1.0, 1.0),
                   (-1.0, 1.0, -1.0), (1.0, -1.0, -1.0)]
    elif geometry == "Trigonal Pyramidal":
        coords += [(1.0, 0.0, -0.5), (-0.5, math.sqrt(3)/2, -0.5),
                   (-0.5, -math.sqrt(3)/2, -0.5)]
    elif geometry == "Trigonal Bipyramidal":
        coords += [(1.0, 0.0, 0.0), (-1.0, 0.0, 0.0),
                   (0.0, 1.0, 0.0), (0.0, -1.0, 0.0), (0.0, 0.0, 1.0)]
    elif geometry == "See-Saw":
        coords += [(1.0, 0.0, 0.0), (-1.0, 0.0, 0.0),
                   (0.0, 1.0, 0.0), (0.0, -1.0, 0.0)]
    elif geometry == "T-Shaped":
        coords += [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, -1.0, 0.0)]
    elif geometry == "Octahedral":
        coords += [(1.0, 0.0, 0.0), (-1.0, 0.0, 0.0),
                   (0.0, 1.0, 0.0), (0.0, -1.0, 0.0),
                   (0.0, 0.0, 1.0), (0.0, 0.0, -1.0)]
    elif geometry == "Square Planar":
        coords += [(1.0, 0.0, 0.0), (-1.0, 0.0, 0.0),
                   (0.0, 1.0, 0.0), (0.0, -1.0, 0.0)]
    else:
        for i in range(3):
            theta = 2 * math.pi * i / 3
            coords.append((math.cos(theta), math.sin(theta), 0.0))
    return coords

def write_xyz(atom_symbols, coords, filename):
    with open(filename, "w") as f:
        f.write(f"{len(atom_symbols)}\nGenerated by VSEPR Generator\n")
        for symbol, (x, y, z) in zip(atom_symbols, coords):
            f.write(f"{symbol} {x:.4f} {y:.4f} {z:.4f}\n")

# Open Babel UFF Minimization
def minimize_xyz_with_openbabel(input_xyz, output_xyz="optimized9.xyz", forcefield="UFF"):
    try:
        result = subprocess.run([
            "obabel", "-ixyz", input_xyz, "-oxyz", "-O", output_xyz,
            "--minimize", "--ff", forcefield
        ], capture_output=True, text=True)
        if result.returncode == 0:
            print(f"Geometry minimized and saved as '{output_xyz}' using {forcefield}")
        else:
            print("Open Babel error:\n", result.stderr)
    except Exception as e:
        print("Open Babel not found or error occurred:", e)

# ANI-2x Refinement
def refine_with_ani(input_xyz="optimized9.xyz", output_xyz="refined_ani2x.xyz"):
    print("Running ANI-2x optimization...")
    model = torchani.models.ANI2x().to("cpu")

    def read_xyz(filename):
        with open(filename) as f:
            lines = f.readlines()[2:]
        symbols, coords = [], []
        for line in lines:
            parts = line.split()
            symbols.append(parts[0])
            coords.append([float(x) for x in parts[1:4]])
        return symbols, np.array(coords)

    def write_xyz(symbols, coords, filename):
        with open(filename, "w") as f:
            f.write(f"{len(symbols)}\nRefined with ANI-2x\n")
            for s, (x, y, z) in zip(symbols, coords):
                f.write(f"{s} {x:.6f} {y:.6f} {z:.6f}\n")

    symbols, coords = read_xyz(input_xyz)

    supported = {'H', 'C', 'N', 'O', 'F', 'S', 'Cl'}
    if any(s not in supported for s in symbols):
        print(f"ANI-2x does not support these atoms: {set(symbols) - supported}")
        return

    try:
        species = model.species_to_tensor(symbols).unsqueeze(0)
    except Exception as e:
        print(f"ANI-2x species conversion error: {e}")
        return

    coordinates = torch.tensor([coords], requires_grad=True, dtype=torch.float32)
    optimizer = torch.optim.LBFGS([coordinates], max_iter=100)

    def closure():
        optimizer.zero_grad()
        energy = model((species, coordinates)).energies
        energy.backward()
        return energy

    optimizer.step(closure)
    refined_coords = coordinates.detach().numpy()[0]
    write_xyz(symbols, refined_coords, output_xyz)
    print(f"ANI-2x refined structure saved to '{output_xyz}'")

#  Main SMILES Analysis(For parsing the SMILES input with RDkit)
def analyze_smiles(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print("Invalid SMILES string.")
        return

    mol = Chem.AddHs(mol)

    central_atoms = [atom for atom in mol.GetAtoms() if atom.GetSymbol() != "H" and atom.GetDegree() >= 2]
    if not central_atoms:
        print("No central atom (non-H with degree â‰¥ 2) found.")
        return

    for atom in central_atoms:
        idx = atom.GetIdx()
        symbol = atom.GetSymbol()
        bonded_atoms = atom.GetDegree()
        lone_pairs = estimate_lone_pairs(atom)
        (geometry, hybridization, angle), steric_number = vsepr_predictor(bonded_atoms, lone_pairs)

        print(f"\nðŸ”¹ Central Atom: {symbol} (index {idx})")
        print(f"  Bonded atoms: {bonded_atoms}")
        print(f"  Lone pairs: {lone_pairs}")
        print(f"  Steric number: {steric_number}")
        print(f"  Hybridization: {hybridization}")
        print(f"  Geometry: {geometry}")
        print(f"  Bond angle: {angle}Â°")

        bonded = [a for a in atom.GetNeighbors()]
        atom_symbols = [symbol] + [a.GetSymbol() for a in bonded]

        coords = generate_coordinates(geometry)
        write_xyz(atom_symbols, coords, "generated9.xyz")
        print("Structure written to 'generated9.xyz'")

        minimize_xyz_with_openbabel("generated9.xyz", "optimized9.xyz")
        refine_with_ani("optimized9.xyz", "refined_ani2x.xyz")

#  Run Script 
if __name__ == "__main__":
    smiles = input("ðŸ”· Enter SMILES: ").strip()
    analyze_smiles(smiles)





